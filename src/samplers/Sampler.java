package samplers;

import utilities.*;

import javax.swing.*;
import java.awt.*;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.geom.Line2D;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

abstract public class Sampler {

/*--------------------------------------------------------------------------------------------------------------------*\
 *  Fields
\*--------------------------------------------------------------------------------------------------------------------*/

    /**
     * The number of sample points in a pattern.
     */
    int numSamples = 1;

    /**
     * The number of sample sets (patterns) stored. The default value is 83, which has nothing special but only a prime.
     */
    int numSets = 83;

    /**
     * The current number of sample points used. It is initialized to zero when a Sampler object is constructed. It is
     * incremented by one each time the method <code>nextSampleOnUnitSquare</code> is called, its value at the end of
     * each function call is the total number of sample points returned at the time.
     */
    long count = 0;

    /**
     * Random index jump.
     */
    int jump = 0;

    /**
     * Shuffled squareSamples array indices.
     */
    List<Integer> shuffledIndices = new ArrayList<>();

    /**
     * Sample points on a unit square generated by the method <code>generateSamples()</code>. It's a 1D array but can be
     * accessed using index. For most sampling applications, it's important to use different sets with adjacent pixels.
     * If we don't do this, the results can be aliasing artifacts that are far worse than the jaggies.
     */
    List<Point2D> squareSamples = new ArrayList<>();

    /**
     * Samples mapped from the <code>squareSamples</code> to samples on a disk. Call <code>mapSamplesToUnitDisk</code>
     * before using samples on a disk.
     */
    List<Point2D> diskSamples = new ArrayList<>();

    /**
     * Samples mapped from the <code>squareSamples</code> to samples on a disk. Call <code>mapSamplesToHemisphere</code>
     * before using samples on a hemisphere.
     */
    List<Point3D> hemisphereSamples = new ArrayList<>();

    private boolean isSquareSamplesGenerated = false;
    private boolean isDiskSamplesGenerated = false;
    private boolean isHemisphereSamples = false;


/*--------------------------------------------------------------------------------------------------------------------*\
 *  Constructors
\*--------------------------------------------------------------------------------------------------------------------*/

    public Sampler(int numSamples) {
        this.numSamples = numSamples;
        this.generateSamples();
    }

    public Sampler(int numSamples, int numSets) {
        this.numSamples = numSamples;
        this.numSets = numSets;
        this.generateSamples();
    }

/*--------------------------------------------------------------------------------------------------------------------*\
 *  Sampler specific methods
\*--------------------------------------------------------------------------------------------------------------------*/

    /**
     * Generates sample patterns in a unit square, stored in data field <code>squareSamples</code>. Each subclass has to
     * override this method. It doesn't need to be called explicitly but called by the constructor by default.
     */
    abstract public void generateSamples();

    /**
     * Maps sample points in a unit square to a unit disk stored in the<code>diskSamples</code>. It is called when
     * constructing an object that has to supply squareSamples on a disk. This method applies the concentric map
     * developed by Shirley in the early 1990s.
     *
     * At the beginning of the method, it will check whether squareSamples are generated. If not, it will generate them
     * first by calling {@see Sampler#generateSamples()}. After it's done mapping, it will set
     * <code>isDiskSamplesGenerated</code> to true.
     */
    public void mapSamplesToUnitDisk() {
        if (!isSquareSamplesGenerated)
            generateSamples();

        double r, phi;  // polar coordinate
        Point2D sp;     // sample point on unit

        for (Point2D p : squareSamples) {
            sp = p.mul(2).sub(1);
            if (sp.x > -sp.y) {
                if (sp.x > sp.y) {
                    r = sp.x;
                    phi = sp.y / sp.x;
                } else {
                    r = sp.y;
                    phi = 2 - sp.x / sp.y;
                }
            } else {
                if (sp.x < sp.y) {
                    r = -sp.x;
                    phi = 4 + sp.y / sp.x;
                } else {
                    r = -sp.y;
                    phi = (sp.y != 0.0 ? 6 - sp.x / sp.y : 0.0);
                }
            }
            phi *= Math.PI / 4.0;
            diskSamples.add(new Point2D(r * Math.cos(phi), r * Math.sin(phi)).add(1).div(2));
        }

        isDiskSamplesGenerated = true;
    }

    /**
     * Maps sample points in a unit square to a unit hemisphere stored in <code>hemisphereSamples</code>. Similarly to
     * {@see Sampler#mapSamplesToUnitDisk()}.
     */
    public void mapSamplesToHemisphere(double e) {
        if (!isSquareSamplesGenerated)
            generateSamples();

        for (Point2D p : squareSamples) {
            double cos_phi = Math.cos(2.0 * Math.PI * p.x);
            double sin_phi = Math.sin(2.0 * Math.PI * p.x);
            double cos_theta = Math.pow((1.0 - p.y), 1.0 / (e + 1.0));
            double sin_theta = Math.sqrt(1.0 - cos_theta * cos_theta);
            hemisphereSamples.add(new Point3D(
                    (sin_theta * cos_phi + 1) / 2,
                    (sin_theta * sin_phi + 1) / 2,
                    cos_theta
            ));
        }

        isHemisphereSamples = true;
    }

    /**
     * Returns sample points in a unit square. It is called from objects that need to supply sample points on squares.
     * For example, the view plane will do this for every scene.
     *
     * @return the next sample point stored in the sampler object.
     */
    public Point2D nextSampleOnUnitSquare() {
//        if (count % numSamples == 0)
//            jump = Maths.randInt() % numSets;
//        return squareSamples.get(
//                jump + shuffledIndices.get(jump + (int)count++ % numSamples));
        return squareSamples.get((int) count++ % numSamples);
    }

    /**
     * Returns sample points in a unit disk.
     *
     * @return the next sample point in a unit disk stored in the sampler object.
     */
    public Point2D nextSampleOnUnitDisk() {
//        if (count % numSamples == 0)
//            jump = Maths.randInt() % numSets;
//        return diskSamples.get(
//                jump + shuffledIndices.get(jump + (int)count++ % numSamples));
        return diskSamples.get((int) count++ % numSamples);
    }

    /**
     * Returns sample points in a hemisphere.
     *
     * @return the next sample point in a unit disk stored in the sampler object.
     */
    public Point3D nextSampleOnHemisphere() {
//        if (count % numSamples == 0)
//            jump = Maths.randInt() % numSets;
//        return hemisphereSamples.get(
//                jump + shuffledIndices.get(jump + (int)count++ % numSamples));
        return hemisphereSamples.get((int) count++ % numSamples);
    }

/*--------------------------------------------------------------------------------------------------------------------*\
 *  Helper methods
\*--------------------------------------------------------------------------------------------------------------------*/

    /**
     * Sets up the randomly shuffled indices.
     */
    public void setupShuffledIndices() {
        List<Integer> indices =
                IntStream.range(0, numSamples).boxed().collect(Collectors.toList());
        for (int i = 0; i < numSets; i++) {
            Collections.shuffle(indices);       // a set of shuffled indices
            shuffledIndices.addAll(indices.subList(0, numSamples));
        }
    }

    /**
     * Randomly shuffle the squareSamples in each patterns.
     */
    public void shuffleSamples() {

    }

/*--------------------------------------------------------------------------------------------------------------------*\
 *  Getters and setters
\*--------------------------------------------------------------------------------------------------------------------*/

    public int getNumSamples() {
        return numSamples;
    }

    public int getNumSets() {
        return numSets;
    }

    public long getCount() {
        return count;
    }

    public int getJump() {
        return jump;
    }

    public List<Point2D> getSquareSamples() {
        return squareSamples;
    }

    public List<Point2D> getDiskSamples() {
        return diskSamples;
    }

    public List<Point3D> getHemisphereSamples() {
        return hemisphereSamples;
    }

/*--------------------------------------------------------------------------------------------------------------------*\
 *  Tests
\*--------------------------------------------------------------------------------------------------------------------*/

    public static void main(String[] args) {
        int n = 100;
        Sampler s = new Hammersley(n * n, 1);
        hemisphereSamplesVisualization(600, s);
    }

    private static void squareSamplesVisualization(int size, Sampler s, boolean drawGrid) {
        windowManage(size, new JPanel() {
            public void paintComponent(Graphics g) {
                Graphics2D g2d = (Graphics2D) g;
                g2d.setColor(Color.white);
                g2d.fillRect(0, 0, size + 35, size + 35);
                g2d.setColor(Color.gray);
                if (drawGrid) {
                    int n = (int)Math.sqrt(s.numSamples);
                    for (int i = 1; i < n; i++) {
                        g2d.draw(new Line2D.Double(30, size * i / n, 30 + size, size * i / n));
                        g2d.draw(new Line2D.Double(size * i / n + 30, 5, size * i / n + 30, 5 + size));
                    }
                }
                g2d.setColor(Color.black);
                g2d.drawRect(30, 5, size, size);
                g2d.drawRect(5, 5, 20, size);
                g2d.drawRect(30, 10 + size, size, 20);
                s.squareSamples.forEach(e -> {
                    g2d.fillOval((int)(e.x * size + 30 - 2), (int)(e.y * size + 5 - 2), 4, 4);
                    g2d.fillOval((int)(e.x * size + 30 - 2), (int)(size + 20 - 2), 4, 4);
                    g2d.fillOval((int)(15 - 2), (int)(e.y * size + 5 - 2), 4, 4);
                });
            }
        });
    }

    private static void diskSamplesVisualization(int size, Sampler s) {
        s.mapSamplesToUnitDisk();
        windowManage(size, new JPanel() {
            public void paintComponent(Graphics g) {
                Graphics2D g2d = (Graphics2D) g;
                g2d.setColor(Color.white);
                g2d.fillRect(0, 0, size + 35, size + 35);
                g2d.setColor(Color.black);
                g2d.drawRect(5, 5, 20, size);
                g2d.drawRect(30, 10 + size, size, 20);
                g2d.drawOval(30, 5, size, size);
                s.diskSamples.forEach(e -> {
                    g2d.fillOval((int)(e.x * size + 30 - 2), (int)(e.y * size + 5 - 2), 4, 4);
                    g2d.fillOval((int)(e.x * size + 30 - 2), (int)(size + 20 - 2), 4, 4);
                    g2d.fillOval((int)(15 - 2), (int)(e.y * size + 5 - 2), 4, 4);
                });
            }
        });
    }

    private static void hemisphereSamplesVisualization(int size, Sampler s) {
        s.mapSamplesToHemisphere(0);
        windowManage(size, new JPanel() {
            public void paintComponent(Graphics g) {
                Graphics2D g2d = (Graphics2D) g;
                g2d.setColor(Color.white);
                g2d.fillRect(0, 0, size + 35, size + 35);
                g2d.setColor(Color.black);
                g2d.drawRect(5, 5, 20, size);
                g2d.drawRect(30, 10 + size, size, 20);
                g2d.drawOval(30, 5, size, size);
                s.hemisphereSamples.forEach(e -> {
                    g2d.fillOval((int)(e.x * size + 30 - 2), (int)(e.y * size + 5 - 2), 4, 4);
                    g2d.fillOval((int)(e.x * size + 30 - 2), (int)(size + 20 - 2), 4, 4);
                    g2d.fillOval((int)(15 - 2), (int)(e.y * size + 5 - 2), 4, 4);
                });
            }
        });
    }

    private static void windowManage(int size, JPanel panel) {
        JFrame frame = new JFrame("Samples");
        frame.getContentPane().add(BorderLayout.CENTER, panel);
        frame.getContentPane().setPreferredSize(new Dimension(size + 35, size + 35));
        frame.pack();
        frame.setResizable(false);
        frame.addKeyListener(new KeyAdapter() {
            public void keyPressed(KeyEvent e) {
                if (e.getKeyCode() == e.VK_ESCAPE)
                    System.exit(0);
            }
        });
        frame.setVisible(true);
    }
}
